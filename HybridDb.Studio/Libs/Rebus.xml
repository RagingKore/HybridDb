<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Rebus</name>
    </assembly>
    <members>
        <member name="T:Rebus.Bus.AmbientTransactionContext">
            <summary>
            Implementation of <see cref="T:Rebus.ITransactionContext"/> that is tied to an ambient .NET transaction.
            </summary>
        </member>
        <member name="T:Rebus.ITransactionContext">
            <summary>
            Defines a context of a transaction, allowing transports to hook operations up on transaction events
            </summary>
        </member>
        <member name="P:Rebus.ITransactionContext.IsTransactional">
            <summary>
            Indicates whether the current context is actually transactional. If it is not transactional,
            the dictionary will be very short-lived, and you should not subscribe to any events.
            </summary>
        </member>
        <member name="P:Rebus.ITransactionContext.Item(System.String)">
            <summary>
            Gives access to a dictionary of stuff that will be kept for the duration of the transaction.
            </summary>
        </member>
        <member name="E:Rebus.ITransactionContext.DoCommit">
            <summary>
            Will be raised when it is time to commit the transaction. The transport should do its final
            commit work when this event is raised.
            </summary>
        </member>
        <member name="E:Rebus.ITransactionContext.DoRollback">
            <summary>
            Will be raised in the event that the transaction should be rolled back.
            </summary>
        </member>
        <member name="E:Rebus.ITransactionContext.BeforeCommit">
            <summary>
            Will be raised before doing the actual commit
            </summary>
        </member>
        <member name="E:Rebus.ITransactionContext.AfterRollback">
            <summary>
            Will be raised after a transaction has been rolled back
            </summary>
        </member>
        <member name="E:Rebus.ITransactionContext.Cleanup">
            <summary>
            Will be raised after all work is done, allowing you to clean up resources etc.
            </summary>
        </member>
        <member name="M:Rebus.Bus.AmbientTransactionContext.#ctor">
            <summary>
            Constructs the context, enlists it in the ambient transaction, and sets itself as the current context in <see cref="T:Rebus.Bus.TransactionContext"/>.
            </summary>
        </member>
        <member name="T:Rebus.Bus.Dispatcher">
            <summary>
              Implements stuff that must happen when handling one single message.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Dispatcher.#ctor(Rebus.IStoreSagaData,Rebus.IActivateHandlers,Rebus.IStoreSubscriptions,Rebus.IInspectHandlerPipeline,Rebus.Bus.IHandleDeferredMessage)">
            <summary>
            Constructs the dispatcher with the specified instances to store and retrieve saga data,
            create message handlers, store and retrieve subscriptions, and to inspect and
            possibly rearrange the handler pipeline.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Dispatcher.Dispatch``1(``0)">
            <summary>
            Main entry point of the dispatcher. Dispatches the given message, doing handler
            lookup etc. Any exceptions thrown will bubble up.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Dispatcher.DispatchToHandler``1(``0,Rebus.IHandleMessages{``0})">
            <summary>
              Private dispatcher method that gets invoked only via reflection.
            </summary>
        </member>
        <member name="T:Rebus.Bus.IErrorTracker">
            <summary>
            <see cref="T:Rebus.Bus.RebusBus"/> will use its <see cref="T:Rebus.Bus.IErrorTracker"/> to track failed delivery attempts.
            </summary>
        </member>
        <member name="M:Rebus.Bus.IErrorTracker.StopTracking(System.String)">
            <summary>
            Stops tracking the message with the specified ID. If the message is not
            being tracked, nothing happens.
            </summary>
            <param name="id">ID of message to stop tracking</param>
        </member>
        <member name="M:Rebus.Bus.IErrorTracker.MessageHasFailedMaximumNumberOfTimes(System.String)">
            <summary>
            Determines whether the message with the specified ID has failed
            "enough time"
            </summary>
            <param name="id">ID of message to check</param>
            <returns>Whether the message has failed too many times</returns>
        </member>
        <member name="M:Rebus.Bus.IErrorTracker.GetErrorText(System.String)">
            <summary>
            Gets the error messages tracked so far for the message with the specified ID.
            </summary>
            <param name="id">ID of message whose error messages to get</param>
            <returns>Concatenated string of the tracked error messages</returns>
        </member>
        <member name="M:Rebus.Bus.IErrorTracker.TrackDeliveryFail(System.String,System.Exception)">
            <summary>
            Increments the fail count for this particular message, and starts tracking
            the message if it is not already being tracked.
            </summary>
            <param name="id">ID of the message to track</param>
            <param name="exception">The exception that was caught, thus resulting in wanting to track this message</param>
        </member>
        <member name="M:Rebus.Bus.IErrorTracker.GetPoisonMessageInfo(System.String)">
            <summary>
            Retrieves the poison message information collected so far for the message with the specfied id.
            </summary>
        </member>
        <member name="P:Rebus.Bus.IErrorTracker.ErrorQueueAddress">
            <summary>
            Returns the fully qualified address of the error queue to which messages should be forwarded in
            the event that they exceed the accepted number of failed delivery attempts.
            </summary>
        </member>
        <member name="M:Rebus.Bus.ErrorTracker.#ctor(System.TimeSpan,System.TimeSpan,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="timeoutSpan">How long messages will be supervised by the ErrorTracker</param>
            <param name="timeoutCheckInterval">This is the interval that will last between checking whether delivery attempts have been tracked for too long</param>
            <param name="errorQueueAddress">This is the address of the error queue to which messages should be forwarded whenever they are deemed poisonous</param>
        </member>
        <member name="M:Rebus.Bus.ErrorTracker.#ctor(System.String)">
            <summary>
            Default constructor which sets the timeoutSpan to 1 day
            </summary>
        </member>
        <member name="M:Rebus.Bus.ErrorTracker.TrackDeliveryFail(System.String,System.Exception)">
            <summary>
            Increments the fail count for this particular message, and starts tracking
            the message if it is not already being tracked.
            </summary>
            <param name="id">ID of the message to track</param>
            <param name="exception">The exception that was caught, thus resulting in wanting to track this message</param>
        </member>
        <member name="M:Rebus.Bus.ErrorTracker.StopTracking(System.String)">
            <summary>
            Stops tracking the message with the specified ID. If the message is not
            being tracked, nothing happens.
            </summary>
            <param name="id">ID of message to stop tracking</param>
        </member>
        <member name="M:Rebus.Bus.ErrorTracker.GetErrorText(System.String)">
            <summary>
            Gets the error messages tracked so far for the message with the specified ID.
            </summary>
            <param name="id">ID of message whose error messages to get</param>
            <returns>Concatenated string of the tracked error messages</returns>
        </member>
        <member name="M:Rebus.Bus.ErrorTracker.GetPoisonMessageInfo(System.String)">
            <summary>
            Retrieves information about caught exceptions for the message with the
            given id.
            </summary>
            <param name="id">ID of message whose poison message information to get</param>
            <returns>Information about the poison message</returns>
        </member>
        <member name="M:Rebus.Bus.ErrorTracker.MessageHasFailedMaximumNumberOfTimes(System.String)">
            <summary>
            Determines whether the message with the specified ID has failed
            "enough time"
            </summary>
            <param name="id">ID of message to check</param>
            <returns>Whether the message has failed too many times</returns>
        </member>
        <member name="T:Rebus.Bus.PoisonMessageInfo">
            <summary>
            Represents a message and information about exceptions that have been caught while attempting
            to process the message.
            </summary>
        </member>
        <member name="P:Rebus.Bus.PoisonMessageInfo.Id">
            <summary>
            The id of the transport message.
            </summary>
        </member>
        <member name="P:Rebus.Bus.PoisonMessageInfo.Exceptions">
            <summary>
            Collection of exceptions caught at specific times while processing the message.
            </summary>
        </member>
        <member name="T:Rebus.Bus.TimedException">
            <summary>
            Represents an exceptions that has been caught at some specific time.
            </summary>
        </member>
        <member name="T:Rebus.Bus.IMulticastTransport">
            <summary>
            Adds to <see cref="T:Rebus.IDuplexTransport"/> the ability to send to multiple recipients at
            once by using pub sub messaging. This implies that the transport can somehow persist
            subscriptions and take care of routing to subscribers.
            </summary>
        </member>
        <member name="T:Rebus.IDuplexTransport">
            <summary>
            Interface of something that is capable of sending and receiving messages at the same time, using the
            same channel type thus allowing it to send messages to itself.
            </summary>
        </member>
        <member name="T:Rebus.ISendMessages">
            <summary>
            Interface of something that is capable of sending a <see cref="T:Rebus.TransportMessageToSend"/> somewhere.
            </summary>
        </member>
        <member name="M:Rebus.ISendMessages.Send(System.String,Rebus.TransportMessageToSend,Rebus.ITransactionContext)">
            <summary>
            Sends the specified <see cref="T:Rebus.TransportMessageToSend"/> to the endpoint with the specified input queue name,
            enlisting in the specified <see cref="T:Rebus.ITransactionContext"/>.
            </summary>
        </member>
        <member name="T:Rebus.IReceiveMessages">
            <summary>
            Interface of something that is capable of receiving messages. If no message is available,
            null should be returned. If the bus is configured to run with multiple threads, this one
            should be reentrant.
            </summary>
        </member>
        <member name="M:Rebus.IReceiveMessages.ReceiveMessage(Rebus.ITransactionContext)">
            <summary>
            Attempt to receive the next available message. Should return null if no message is available.
            </summary>
        </member>
        <member name="P:Rebus.IReceiveMessages.InputQueue">
            <summary>
            Gets the name of this receiver's input queue - i.e. this is the queue that this receiver
            will pull messages from.
            </summary>
        </member>
        <member name="P:Rebus.IReceiveMessages.InputQueueAddress">
            <summary>
            Gets the globally accessible adddress of this receiver's input queue - i.e. this would probably
            be the input queue in some form, possible qualified by machine name or something similar.
            </summary>
        </member>
        <member name="M:Rebus.Bus.IMulticastTransport.Subscribe(System.Type,System.String)">
            <summary>
            Subscribes the specified input queue address to messages of the specified type
            </summary>
        </member>
        <member name="M:Rebus.Bus.IMulticastTransport.Unsubscribe(System.Type,System.String)">
            <summary>
            Unsubscribes the specified input queue address from messages of the specified type
            </summary>
        </member>
        <member name="P:Rebus.Bus.IMulticastTransport.ManagesSubscriptions">
            <summary>
            Indicates whether this multicast-capable transport IS in fact supposed to do multicast
            </summary>
        </member>
        <member name="T:Rebus.Bus.NoTransaction">
            <summary>
            Transaction context that really means "no transaction". Sort of a null object implementation
            of a transaction context.
            </summary>
        </member>
        <member name="M:Rebus.Bus.NoTransaction.#ctor">
            <summary>
            Constructs the context and sets itself as current in <see cref="T:Rebus.Bus.TransactionContext"/>.
            </summary>
        </member>
        <member name="T:Rebus.IRebusBatchOperations">
            <summary>
            Groups the batch operations that Rebus can perform.
            </summary>
        </member>
        <member name="M:Rebus.IRebusBatchOperations.Send(System.Object[])">
            <summary>
            Sends the specified batch of messages, dividing the batch into batches
            for individual recipients if necessary. For each recipient, the order
            of the messages within the batch is preserved.
            </summary>
        </member>
        <member name="M:Rebus.IRebusBatchOperations.Publish(System.Object[])">
            <summary>
            Publishes the specified batch of messages, dividing the batch into
            batches for individual recipients if necessary. For each subscriber,
            the order of the messages within the batch is preserved.
            </summary>
        </member>
        <member name="M:Rebus.IRebusBatchOperations.Reply(System.Object[])">
            <summary>
            Sends a batch of replies back to the sender of the message currently being handled.
            Can only be called when a <see cref="T:Rebus.MessageContext"/> has been established, which happens
            during the handling of an incoming message.
            </summary>
        </member>
        <member name="T:Rebus.IRebusEvents">
            <summary>
            Groups the different event hooks that Rebus exposes.
            </summary>
        </member>
        <member name="E:Rebus.IRebusEvents.BeforeTransportMessage">
            <summary>
            Event that will be raised immediately after receiving a transport 
            message, before any other actions are executed.
            </summary>
        </member>
        <member name="E:Rebus.IRebusEvents.AfterTransportMessage">
            <summary>
            Event that will be raised after a transport message has been handled.
            If an error occurs, the caught exception will be passed to the
            listeners. If no errors occur, the passed exception will be null.
            </summary>
        </member>
        <member name="E:Rebus.IRebusEvents.PoisonMessage">
            <summary>
            Event that will be raised whenever it is determined that a message
            has failed too many times.
            </summary>
        </member>
        <member name="E:Rebus.IRebusEvents.MessageSent">
            <summary>
            Event that will be raised immediately when the bus is used to send a logical message.
            </summary>
        </member>
        <member name="E:Rebus.IRebusEvents.BeforeMessage">
            <summary>
            Event that will be raised for each received logical message (i.e. it will only be called
            if deserialization completed, and the transport message does in fact contain one or more
            logical messages).
            </summary>
        </member>
        <member name="E:Rebus.IRebusEvents.AfterMessage">
            <summary>
            Event that will be raised for each received logical message (i.e. it will only be called
            if deserialization completed, and the transport message does in fact contain one or more
            logical messages).
            </summary>
        </member>
        <member name="E:Rebus.IRebusEvents.UncorrelatedMessage">
            <summary>
            Event that is raised when an incoming message can be handled by a saga handler, but it
            turns out that no saga data instance could be correlated with the message.
            </summary>
        </member>
        <member name="P:Rebus.IRebusEvents.MessageMutators">
            <summary>
            Contains a pipeline of message mutators that will be run in order when messages are sent,
            and in reverse order when messages are received.
            </summary>
        </member>
        <member name="T:Rebus.IRebusRouting">
            <summary>
            Groups Rebus' operations for manually routing messages.
            </summary>
        </member>
        <member name="M:Rebus.IRebusRouting.Send``1(System.String,``0)">
            <summary>
            Sends the specified message to the specified destination.
            </summary>
        </member>
        <member name="M:Rebus.IRebusRouting.Subscribe``1(System.String)">
            <summary>
            Sends a subscription request for <typeparamref name="TEvent"/> to the specified 
            destination.
            </summary>
        </member>
        <member name="M:Rebus.IRebusRouting.ForwardCurrentMessage(System.String)">
            <summary>
            Sends the message currently being handled to the specified endpoint, preserving all
            of the transport level headers.
            </summary>
        </member>
        <member name="T:Rebus.Bus.TransactionContext">
            <summary>
            Gives access to a thread-bound <see cref="T:Rebus.ITransactionContext"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.TxBomkarl.#ctor">
            <summary>
            Constructs the context and sets itself as current in <see cref="T:Rebus.Bus.TransactionContext"/>.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.BaseConfigurer">
            <summary>
            Base class of all configurers. Defines what a configurer has access to, and might provide some
            conveniene methods to do common configuration stuff.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.BuiltinContainerAdapter">
            <summary>
            Very simple and independent container adapter that relies on <see cref="T:Rebus.SimpleHandlerActivator"/>
            to activate handlers.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.IContainerAdapter">
            <summary>
            Extends <see cref="T:Rebus.IActivateHandlers"/> into a container adapter,
            which has the capability of storing the created bus instance(s)
            and disposing it/them at the right time - usually when the application
            ends (i.e. when the underlying IoC container is disposed).
            </summary>
        </member>
        <member name="T:Rebus.IActivateHandlers">
            <summary>
            Implement this in order to delegate the instantiation work to your
            IoC container. Seriously, do it.
            </summary>
        </member>
        <member name="M:Rebus.IActivateHandlers.GetHandlerInstancesFor``1">
            <summary>
            Should get a sequence of handlers where each handler implements
            the <see cref="T:Rebus.IHandleMessages`1"/> interface.
            </summary>
        </member>
        <member name="M:Rebus.IActivateHandlers.Release(System.Collections.IEnumerable)">
            <summary>
            Is called after each handler has been invoked. Please note that this method
            will be called for all handlers - i.e. if you add more handlers to the pipeline
            in the Filter method of <see cref="T:Rebus.IInspectHandlerPipeline"/>, this method will
            be called for those additional handlers as well. This, in turn, allows you to
            implement <see cref="T:Rebus.IInspectHandlerPipeline"/>, supplying your implementation
            of <see cref="T:Rebus.IActivateHandlers"/> to that implementation, allowing any manually
            pulled handler instances to be released in the right way.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.IContainerAdapter.SaveBusInstances(Rebus.IBus,Rebus.IAdvancedBus)">
            <summary>
            Instructs the container to save the specified bus instance(s) 
            and take responsibility of their disposal when it's the right time.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.BuiltinContainerAdapter.Register(System.Type)">
            <summary>
            Registers the given handler type. It is assumed that the type registered has a public
            default constructor - otherwise, instantiation will fail.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.BuiltinContainerAdapter.Register``1(System.Func{``0})">
            <summary>
            Registers a factory method that is capable of creating a handler instance.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.BuiltinContainerAdapter.Handle``1(System.Action{``0})">
            <summary>
            Registers a function that can handle messages of the specified type.
            </summary>
        </member>
        <member name="P:Rebus.Configuration.BuiltinContainerAdapter.Bus">
            <summary>
            Use this property to access the bus instance
            </summary>
        </member>
        <member name="P:Rebus.Configuration.BuiltinContainerAdapter.AdvancedBus">
            <summary>
            Use this property to access the advanced bus, which is an ordinary bus plus some advanced operations
            </summary>
        </member>
        <member name="T:Rebus.Configuration.ConfigurationBackbone">
            <summary>
            The backbone holds configured instances of Rebus' abstractions
            </summary>
        </member>
        <member name="M:Rebus.Configuration.ConfigurationBackbone.#ctor(Rebus.Configuration.IContainerAdapter)">
            <summary>
            Creates the backbone and installs the specified <see cref="T:Rebus.Configuration.IContainerAdapter"/> as the
            current implementation of <see cref="T:Rebus.IActivateHandlers"/>.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.Configure">
            <summary>
            Main configuration API entry point.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.Configure.With(Rebus.Configuration.IContainerAdapter)">
            <summary>
            Starts configuring Rebus with the specified container adapter.
            </summary>
        </member>
        <member name="T:Rebus.ExceptionExtensions">
            <summary>
            Extensions useful for doing special stuff on exceptions.
            </summary>
        </member>
        <member name="M:Rebus.ExceptionExtensions.PreserveStackTrace(System.Exception)">
            <summary>
            Modifies the specified exception's _remoteStackTraceString. I have no idea
            how this works, but it allows for unpacking a re-throwable inner exception
            from a caught <see cref="T:System.Reflection.TargetInvocationException"/>.
            </summary>
        </member>
        <member name="T:Rebus.IMutateMessages">
            <summary>
            Implement this in order to get a hook that gets to mutate incoming and outgoing messages.
            </summary>
        </member>
        <member name="M:Rebus.IMutateMessages.MutateIncoming(System.Object)">
            <summary>
            Will be called once for each incoming logical message before it gets dispatched to handlers.
            </summary>
        </member>
        <member name="M:Rebus.IMutateMessages.MutateOutgoing(System.Object)">
            <summary>
            Will be called once for each outgoing logical message before it gets added to the outgoing
            transport message.
            </summary>
        </member>
        <member name="T:Rebus.Testing.FakeBus">
            <summary>
            Implementation of <see cref="T:Rebus.IBus"/> that is meant to be used in tests. Collects
            all sent messages and headers etc., allowing tests to inspect them during the
            assert phase of the test.
            </summary>
        </member>
        <member name="T:Rebus.IBus">
            <summary>
            This is the main API of Rebus. Most application code should not depend on
            any other operation of <see cref="T:Rebus.Bus.RebusBus"/>.
            </summary>
        </member>
        <member name="M:Rebus.IBus.Send``1(``0)">
            <summary>
            Sends the specified message to the destination as specified by the currently
            used implementation of <see cref="T:Rebus.IDetermineDestination"/>.
            </summary>
        </member>
        <member name="M:Rebus.IBus.SendLocal``1(``0)">
            <summary>
            Sends the specified message to the bus' own input queue.
            </summary>
        </member>
        <member name="M:Rebus.IBus.Reply``1(``0)">
            <summary>
            Sends a reply back to the sender of the message currently being handled. Can only
            be called when a <see cref="T:Rebus.MessageContext"/> has been established, which happens
            during the handling of an incoming message.
            </summary>
        </member>
        <member name="M:Rebus.IBus.Subscribe``1">
            <summary>
            Sends a subscription request for <typeparamref name="TEvent"/> to the destination as
            specified by the currently used implementation of <see cref="T:Rebus.IDetermineDestination"/>.
            </summary>
        </member>
        <member name="M:Rebus.IBus.Unsubscribe``1">
            <summary>
            Sends an unsubscription request for <typeparamref name="TEvent"/> to the destination as
            specified by the currently used implementation of <see cref="T:Rebus.IDetermineDestination"/>.
            </summary>
        </member>
        <member name="M:Rebus.IBus.Publish``1(``0)">
            <summary>
            Publishes the specified event message to all endpoints that are currently subscribed.
            The publisher should have some kind of <see cref="T:Rebus.IStoreSubscriptions"/> implementation,
            preferably a durable implementation like e.g. <see cref="T:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage"/>.
            </summary>
        </member>
        <member name="M:Rebus.IBus.Defer(System.TimeSpan,System.Object)">
            <summary>
            Sends the message to the timeout manager, which will send it back after the specified
            time span has elapsed. Note that you must have a running timeout manager for this to
            work.
            </summary>
        </member>
        <member name="M:Rebus.IBus.AttachHeader(System.Object,System.String,System.String)">
            <summary>
            Attaches to the specified message a header with the given key and value. The header will
            be associated with the message, and will be supplied when the message is sent - even if
            it is sent multiple times.
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.GetAttachedHeaders(System.Object)">
            <summary>
            Accesses the accumulated list of attached headers for one specific message.
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeBus.SentMessages">
            <summary>
            Accesses the accumulated list of sent messages.
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeBus.PublishedMessages">
            <summary>
            Accesses the accumulated list of published messages.
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeBus.LocallySentMessages">
            <summary>
            Accesses the accumulated list messages sent to self.
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeBus.Replies">
            <summary>
            Accesses the accumulated list of replies sent.
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeBus.Subscriptions">
            <summary>
            Accesses the accumulated list of subscriptions made.
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeBus.DeferredMessages">
            <summary>
            Accesses the accumulated list of messages deferred to the future.
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeBus.AttachedHeaders">
            <summary>
            Accesses the accumulated list of attached headers.
            </summary>
        </member>
        <member name="T:Rebus.Testing.FakeBus.DeferredMessage">
            <summary>
            Contains information about a message deferred to the future.
            </summary>
        </member>
        <member name="T:Rebus.Testing.SagaFixture`1">
            <summary>
            Saga fixture that can help unit testing sagas.
            </summary>
        </member>
        <member name="M:Rebus.Testing.SagaFixture`1.#ctor(Rebus.Saga{`0},System.Collections.Generic.IList{`0})">
            <summary>
            Constructs the fixture with the given saga and the given saga data available. The <see cref="F:Rebus.Testing.SagaFixture`1.availableSagaData"/>
            list will be used to look for existing saga data instances, and new ones will be added to this list as well.
            </summary>
        </member>
        <member name="M:Rebus.Testing.SagaFixture`1.#ctor(Rebus.Saga{`0})">
            <summary>
            Constructs the fixture with the given saga.
            </summary>
        </member>
        <member name="M:Rebus.Testing.SagaFixture`1.Handle``1(``0)">
            <summary>
            Dispatches a message to the saga, raising the appropriate events along the way.
            </summary>
        </member>
        <member name="E:Rebus.Testing.SagaFixture`1.CorrelatedWithExistingSagaData">
            <summary>
            Gets raised during message dispatch when the message could be correlated with an existing saga data instance.
            The event is raised before the message is handled by the saga.
            </summary>
        </member>
        <member name="E:Rebus.Testing.SagaFixture`1.CreatedNewSagaData">
            <summary>
            Gets raised during message dispatch when the message could not be correlated with an existing saga data instance
            and a new saga data instance was created. The event is raised before the message is handled by the saga.
            </summary>
        </member>
        <member name="E:Rebus.Testing.SagaFixture`1.CouldNotCorrelate">
            <summary>
            Gets raised during message dispatch when the message could not be correlated with a saga data instance, and 
            creating a new saga data instance was not allowed.
            </summary>
        </member>
        <member name="P:Rebus.Testing.SagaFixture`1.Data">
            <summary>
            Gives access to the currently correlated piece of saga data. If none could be correlated, 
            null is returned.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.HelpText">
            <summary>
            Can be used to store code snippets meant to be shown in error messages. Embedded code snippets should be replaced
            by usage of consts from this class.
            </summary>
        </member>
        <member name="F:Rebus.Configuration.HelpText.TransportConfigurationExample">
            <summary>
            Shows a very basic and explicit example on how Rebus can be configured to use MSMQ.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusRoutingConfigurer.FromNServiceBusConfiguration">
            <summary>
            Configures Rebus to pick up endpoint mappings in NServiceBus format from the current app.config/web.config.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusRoutingConfigurer.FromRebusConfigurationSection">
            <summary>
            Configures Rebus to expect endpoint mappings to be on Rebus form.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusRoutingConfigurer.FromRebusConfigurationSectionWithFilter(System.Func{System.Type,System.Boolean})">
            <summary>
            Configures Rebus to expect endpoint mappings to be on Rebus form.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusSagasConfigurer.StoreInSqlServer(System.String,System.String,System.String)">
            <summary>
            Configures Rebus to store sagas in SQL Server. Use this overload when your saga doesn't perform
            any additional work in the same SQL Server.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusSagasConfigurer.StoreInSqlServer(System.Func{System.Data.SqlClient.SqlConnection},System.String,System.String)">
            <summary>
            Configures Rebus to store sagas in SQL Server. Use this overload to have the persister use the
            same <see cref="T:System.Data.SqlClient.SqlConnection"/> as you're using, thus enlisting in whatever transactional
            behavior you might be using.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusSagasConfigurer.StoreInMemory">
            <summary>
            Configures Rebus to store sagas in memory. This should only be used for very short-lived sagas
            that you can afford to lose on each restart/server crash etc. It's also cool for debugging and
            running stuff locally.
            </summary>
        </member>
        <member name="T:Rebus.MessageSentEventHandler">
            <summary>
            Delegate type that can listen to whenever the bus sends a logical message.
            </summary>
        </member>
        <member name="T:Rebus.BeforeMessageEventHandler">
            <summary>
            Delegate type that can listen to whenever the bus received a logical message.
            </summary>
        </member>
        <member name="T:Rebus.AfterMessageEventHandler">
            <summary>
            Delegate type that can listen to whenever the bus received a logical message.
            </summary>
        </member>
        <member name="T:Rebus.BeforeTransportMessageEventHandler">
            <summary>
            Delegate type that can listen to whenever the bus has received a transport message, but it has not yet been deserialized.
            </summary>
        </member>
        <member name="T:Rebus.AfterTransportMessageEventHandler">
            <summary>
            Delegate type that can listen to whenever the bus has received and dispatched a transport message, and then - depending on how that
            went - and exception might be passed along.
            </summary>
        </member>
        <member name="T:Rebus.PoisonMessageEventHandler">
            <summary>
            Delegate type that can listen to whenever the bus has decided that message is poison, and should be moved to the error queue.
            </summary>
        </member>
        <member name="T:Rebus.UncorrelatedMessageEventHandler">
            <summary>
            Delegate type that can listen when an incoming message can be handled by a saga handler, but it turns out that there was no saga data that could be correlated with the message.
            </summary>
        </member>
        <member name="T:Rebus.IAdvancedBus">
            <summary>
            Extends the capabilities of <see cref="T:Rebus.IBus"/> with some more advanced features.
            </summary>
        </member>
        <member name="P:Rebus.IAdvancedBus.Events">
            <summary>
            Gives access to all the different event hooks that Rebus exposes.
            </summary>
        </member>
        <member name="P:Rebus.IAdvancedBus.Batch">
            <summary>
            Gives access to Rebus' batch operations.
            </summary>
        </member>
        <member name="P:Rebus.IAdvancedBus.Routing">
            <summary>
            Gives access to Rebus' routing operations.
            </summary>
        </member>
        <member name="T:Rebus.IHandleMessages`1">
            <summary>
            This is the main message handler interface of Rebus. Implement these to be
            called when messages are dispatched.
            </summary>
            <typeparam name="TMessage">The type of the message being handled. Can be any assignable type as well.</typeparam>
        </member>
        <member name="T:Rebus.IHandleMessages">
            <summary>
            Top level handler interface that allows for interacting with handlers in
            a message type-agnostic manner.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.DetermineDestinationFromRebusConfigurationSection">
            <summary>
            Configures endpoint mappings from a <see cref="T:Rebus.Configuration.RebusConfigurationSection"/> configuration section.
            </summary>
        </member>
        <member name="T:Rebus.IDetermineDestination">
            <summary>
            Should be capable of looking up endpoints from message types - i.e.
            answer the question: "Who owns messages of this type?"
            </summary>
        </member>
        <member name="M:Rebus.IDetermineDestination.GetEndpointFor(System.Type)">
            <summary>
            Gets the name of the endpoint that is configured to be the owner of the specified message type.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.FluentRearrangeHandlersPipelineInspectorBuilder">
            <summary>
            Aids in configuring and adding a <see cref="T:Rebus.Configuration.RearrangeHandlersPipelineInspector"/>.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.FluentRearrangeHandlersPipelineInspectorBuilder.Then``1">
            <summary>
            Configures the <see cref="T:Rebus.Configuration.RearrangeHandlersPipelineInspector"/> to re-arrange the handler
            pipeline, ensuring that the order specified by your calls to <see cref="M:Rebus.Configuration.RearrangeHandlersPipelineInspectorExtensions.First``1(Rebus.Configuration.PipelineInspectorConfigurer)"/>
            and <see cref="M:Rebus.Configuration.FluentRearrangeHandlersPipelineInspectorBuilder.Then``1"/> are respected.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RearrangeHandlersPipelineInspectorExtensions.First``1(Rebus.Configuration.PipelineInspectorConfigurer)">
            <summary>
            Configures the <see cref="T:Rebus.Configuration.RearrangeHandlersPipelineInspector"/> to re-arrange the handler
            pipeline, ensuring that the specified handler type <typeparamref name="THandler"/> is
            executed first, followed by any handlers specified by calling <seealso cref="M:Rebus.Configuration.FluentRearrangeHandlersPipelineInspectorBuilder.Then``1"/>.
            </summary>
        </member>
        <member name="T:Rebus.Testing.FakeMessageContext">
            <summary>
            Allows you to establish a fake message context for the duration of a test.
            It should only be necessary to use <see cref="T:Rebus.Testing.FakeMessageContext"/> in places
            where you cannot set up your DI container to automatically inject the current
            <see cref="T:Rebus.IMessageContext"/>.
            In tests where this one is used, you should take care to always call
            <see cref="M:Rebus.Testing.FakeMessageContext.Reset"/> as part of the test teardown logic.
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeMessageContext.Establish(Rebus.IMessageContext)">
            <summary>
            Attaches the specified (most likely mocked) message context to the current thread,
            which will cause <see cref="M:Rebus.MessageContext.GetCurrent"/> to return it.
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeMessageContext.Reset">
            <summary>
            Removes any attached message contexts from the current thread.
            </summary>
        </member>
        <member name="T:Rebus.IMessageContext">
            <summary>
            This is 
            </summary>
        </member>
        <member name="M:Rebus.IMessageContext.Abort">
            <summary>
            Aborts processing the current message - i.e., after exiting from the
            current handler, no more handlers will be called. Note that this does
            not cause the current transaction to be rolled back.
            </summary>
        </member>
        <member name="P:Rebus.IMessageContext.ReturnAddress">
            <summary>
            Gets the return address of the message that is currently being handled.
            </summary>
        </member>
        <member name="P:Rebus.IMessageContext.TransportMessageId">
            <summary>
            Gets the ID of the message that is currently being handled.
            </summary>
        </member>
        <member name="P:Rebus.IMessageContext.Items">
            <summary>
            Gets the dictionary of objects associated with this message context.
            </summary>
        </member>
        <member name="E:Rebus.IMessageContext.Disposed">
            <summary>
            Raised when the message context is disposed.
            </summary>
        </member>
        <member name="P:Rebus.IMessageContext.CurrentMessage">
            <summary>
            Returns the logical message currently being handled.
            </summary>
        </member>
        <member name="P:Rebus.IMessageContext.Headers">
            <summary>
            Contains the headers of the transport message currently being handled.
            </summary>
        </member>
        <member name="T:Rebus.Lifestyle">
            <summary>
            Basic lifestyles that a given container implementation must support.
            </summary>
        </member>
        <member name="F:Rebus.Lifestyle.Singleton">
            <summary>
            The component is created the first time it is requested, subsequent requests must yield the same instance.
            </summary>
        </member>
        <member name="F:Rebus.Lifestyle.Instance">
            <summary>
            The component is created each time it is requested. It may, however - and that is up to you and the container
            of your choice - be scoped to something, like e.g. an aggregating implementation of <see cref="T:Rebus.IHandleMessages`1"/>
            or something similar.
            </summary>
        </member>
        <member name="T:Rebus.Logging.AbstractRebusLoggerFactory">
            <summary>
            If you intend to implement your own logging, you probably want to derive
            from this class and implement <seealso cref="M:Rebus.Logging.AbstractRebusLoggerFactory.GetLogger(System.Type)"/>.
            </summary>
        </member>
        <member name="T:Rebus.Logging.IRebusLoggerFactory">
            <summary>
            Basic interface of a Rebus logger factory. If you intend to implement your own,
            <see cref="T:Rebus.Logging.AbstractRebusLoggerFactory"/> is the one to derive from - you should
            probably not implement this interface directly.
            </summary>
        </member>
        <member name="M:Rebus.Logging.IRebusLoggerFactory.GetCurrentClassLogger">
            <summary>
            Gets a logger that is initialized to somehow carry information on the class that is using it.
            Be warned that this method will most likely be pretty slow, because it will probably rely on
            some clunky <see cref="T:System.Diagnostics.StackFrame"/> inspection.
            </summary>
        </member>
        <member name="T:Rebus.Logging.ConsoleLoggerExtensions">
            <summary>
            Contains extension methods for configuring logging with builtin logging factories.
            </summary>
        </member>
        <member name="M:Rebus.Logging.ConsoleLoggerExtensions.Console(Rebus.Configuration.LoggingConfigurer)">
            <summary>
            Use console stdout for logging (probably only useful for debugging and test scenarios)
            </summary>
        </member>
        <member name="M:Rebus.Logging.ConsoleLoggerExtensions.Console(Rebus.Configuration.LoggingConfigurer,Rebus.Logging.LogLevel)">
            <summary>
            Use console stdout for logging (probably only useful for debugging and test scenarios)
            </summary>
        </member>
        <member name="M:Rebus.Logging.ConsoleLoggerExtensions.ColoredConsole(Rebus.Configuration.LoggingConfigurer)">
            <summary>
            Use colored console stdout for logging (probably only useful for debugging and test scenarios)
            </summary>
        </member>
        <member name="M:Rebus.Logging.ConsoleLoggerExtensions.ColoredConsole(Rebus.Configuration.LoggingConfigurer,Rebus.Logging.LogLevel)">
            <summary>
            Use colored console stdout for logging (probably only useful for debugging and test scenarios)
            </summary>
        </member>
        <member name="M:Rebus.Logging.ConsoleLoggerExtensions.ColoredConsole(Rebus.Configuration.LoggingConfigurer,Rebus.Logging.LoggingColors)">
            <summary>
            Use colored console stdout for logging (probably only useful for debugging and test scenarios)
            and allow the colors to be customized
            </summary>
        </member>
        <member name="M:Rebus.Logging.ConsoleLoggerExtensions.ColoredConsole(Rebus.Configuration.LoggingConfigurer,Rebus.Logging.LoggingColors,Rebus.Logging.LogLevel)">
            <summary>
            Use colored console stdout for logging (probably only useful for debugging and test scenarios)
            and allow the colors to be customized
            </summary>
        </member>
        <member name="M:Rebus.Logging.ConsoleLoggerExtensions.Trace(Rebus.Configuration.LoggingConfigurer)">
            <summary>
            Use the .NET's <see cref="T:System.Diagnostics.Trace"/> for logging.
            </summary>
        </member>
        <member name="M:Rebus.Logging.ConsoleLoggerExtensions.None(Rebus.Configuration.LoggingConfigurer)">
            <summary>
            Disables logging completely. Why would you do that?
            </summary>
        </member>
        <member name="T:Rebus.Bus.SubscriptionMessageHandler">
            <summary>
            Internal message handler, that handles subscription messages.
            </summary>
        </member>
        <member name="T:Rebus.Bus.Worker">
            <summary>
            Internal worker thread that continually attempts to receive messages and dispatch to handlers.
            </summary>
        </member>
        <member name="F:Rebus.Bus.Worker.dispatchMethodCache">
            <summary>
            Caching of dispatcher methods
            </summary>
        </member>
        <member name="M:Rebus.Bus.Worker.TryProcessIncomingMessage">
            <summary>
            OK - here's how stuff is nested:
            
            - Message queue transaction (TxBomkarl)
                - Before/After transport message
                    - TransactionScope
                        - Before/After logical message
                            Dispatch logical message
            </summary>
        </member>
        <member name="M:Rebus.Bus.Worker.DispatchGeneric``1(``0)">
            <summary>
            Private strongly typed dispatcher method. Will be invoked through reflection to allow
            for some strongly typed interaction from this point and on....
            </summary>
        </member>
        <member name="E:Rebus.Bus.Worker.MessageFailedMaxNumberOfTimes">
            <summary>
            Event that will be raised whenever dispatching a given message has failed MAX number of times
            (usually 5 or something like that).
            </summary>
        </member>
        <member name="E:Rebus.Bus.Worker.UserException">
            <summary>
            Event that will be raised each time message delivery fails.
            </summary>
        </member>
        <member name="E:Rebus.Bus.Worker.SystemException">
            <summary>
            Event that will be raised if an exception occurs outside of user code.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.ConfigurationException">
            <summary>
            Exception that should be thrown in the event that a given configuration is somehow invalid.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.ConfigurationException.#ctor(System.String,System.Object[])">
            <summary>
            Constructs the exception with the specified message.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.DetermineDestinationFromNServiceBusEndpointMappings">
            <summary>
            Implementation of <see cref="T:Rebus.IDetermineDestination"/> that queries the specified XML document
            (loaded from as assembly configuration file or web.config) for endpoint mappings specified on
            the format that NServiceBus understands.
            
            Please note that <see cref="T:Rebus.Configuration.DetermineDestinationFromNServiceBusEndpointMappings"/> is a tad more
            tolerant than NServiceBus - it does not require that the UnicastBusConfig configuration section
            is declared, even though that is required for NServiceBus to work.
            
            If you for some reason have a configuration section with that name that belongs to another
            framework, then that might be a problem.
            
            If you want to alter the behavior of this implementation, feel free to subclass it and override
            any methods that you see fit.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.IAppConfigLoader">
            <summary>
            Abstracts away how an application's app.config is loaded in a dynamic way
            </summary>
        </member>
        <member name="M:Rebus.Configuration.IAppConfigLoader.LoadIt">
            <summary>
            Loads the AppDomain's current app.config and returns the contents as a string
            </summary>
        </member>
        <member name="T:Rebus.Configuration.RearrangeHandlersPipelineInspector">
            <summary>
            Simple implementation of <see cref="T:Rebus.IInspectHandlerPipeline"/> that is capable of
            ordering handlers.
            </summary>
        </member>
        <member name="T:Rebus.IInspectHandlerPipeline">
            <summary>
            Implement this to hook into the final pipeline of handlers. Possible usage scenarios include
            1) ordering handlers before returning them - e.g. ensure that an authentication handler gets 
            executed before anything else, 2) inspecting the incoming message and cherry-picking handlers 
            depending on the contents of the message.
            
            Note that all handlers will be released - i.e. the Release of <see cref="T:Rebus.IActivateHandlers"/>
            will be called for the union of handlers returned from the GetHandlerInstancesFor method and
            any additional handlers that you may have added to return from the Filter method.
            </summary>
        </member>
        <member name="M:Rebus.IInspectHandlerPipeline.Filter(System.Object,System.Collections.Generic.IEnumerable{Rebus.IHandleMessages})">
            <summary>
            Filter the list of handlers before they get executed.
            </summary>
            <param name="message">The message that is being handled.</param>
            <param name="handlers">This is the sequence of handlers that the <see cref="T:Rebus.IActivateHandlers"/> gave us,
            including any internal handlers that may have been added by Rebus.</param>
            <returns>Your (possibly filtered/re-ordered/completely new) sequence of handlers that will actually end up being executed.</returns>
        </member>
        <member name="F:Rebus.Configuration.RearrangeHandlersPipelineInspector.orders">
            <summary>
            Note that <see cref="T:System.Collections.Generic.Dictionary`2"/> is safe for reading from
            multiple threads. It is assumed that <see cref="M:Rebus.Configuration.RearrangeHandlersPipelineInspector.SetOrder(System.Type[])"/> is called
            during some kind of single-threaded startup phase, whereafter calls to
            the filter method may happen in a re-entrant manner.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RearrangeHandlersPipelineInspector.SetOrder(System.Type[])">
            <summary>
            Specifies the desired order of handlers. When this is done, RearrangeHandlersPipelineInspector
            will ensure that all handler pipelines containing one or more handlers from <paramref name="handlerTypes"/>
            will be ordered so that these handlers come first, in the order that they are specified. E.g. 
            if <see cref="M:Rebus.Configuration.RearrangeHandlersPipelineInspector.SetOrder(System.Type[])"/> gets called with handlers A, C, and E, and <see cref="!:Filter&lt;TMessage&gt;"/>
            gets called with handlers B, C, A, E, D, the result is A, C, E, B, D. This method should be called only once.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RearrangeHandlersPipelineInspector.AddToOrder(System.Type)">
            <summary>
            Appends the given type to the order currently stored in the pipeline inspector.
            This method allows this pipeline inspector to be built incrementally, which
            was neede in order to support the fluent configuration API.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.StandardAppConfigLoader">
            <summary>
            <see cref="T:Rebus.Configuration.IAppConfigLoader"/> that can load the application configuration 
            file of the currently activated AppDomain.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.ThrowingEndpointMapper">
            <summary>
            Endpoint mapper that is meant to be used as the default in cases where
            an implementation of <see cref="T:Rebus.IDetermineDestination"/> is not chosen.
            It will throw every time it gets called, and it will do so with a nice
            and friendly error message.
            </summary>
        </member>
        <member name="T:Rebus.Messages.IRebusControlMessage">
            <summary>
            Interface of control bus type messages internal to Rebus
            (but still external enough that you could provide handlers
            for them and have stuff executed upon receiving them).
            </summary>
        </member>
        <member name="T:Rebus.Messages.TimeoutRequest">
            <summary>
            Requests a delayed reply from the Timeout Service. Upon receiving
            this message, the Timeout Service will calculate the UTC time of when the timeout
            should expire, wait, and then reply with a <see cref="T:Rebus.Messages.TimeoutReply"/>.,
            </summary>
        </member>
        <member name="P:Rebus.Messages.TimeoutRequest.Timeout">
            <summary>
            For how long should the reply be delayed?
            </summary>
        </member>
        <member name="P:Rebus.Messages.TimeoutRequest.CorrelationId">
            <summary>
            Allows for specifying a correlation ID that the Timeout Service will
            return with the <see cref="T:Rebus.Messages.TimeoutReply"/>.
            </summary>
        </member>
        <member name="P:Rebus.Messages.TimeoutRequest.CustomData">
            <summary>
            Allows for additional data to be passed along with the timeout. If you really really want,
            you COULD use this field to pass a serialized object.
            </summary>
        </member>
        <member name="P:Rebus.Messages.TimeoutRequest.SagaId">
            <summary>
            Allows for specifying the ID for the saga requesting the timeout.
            The ID will be returned with the <see cref="T:Rebus.Messages.TimeoutReply"/>.
            </summary>
        </member>
        <member name="T:Rebus.Messages.TimeoutReply">
            <summary>
            This is the reply that the Timeout Service will send back to the
            timeout requestor upon completion of the timeout.
            </summary>
        </member>
        <member name="P:Rebus.Messages.TimeoutReply.DueTime">
            <summary>
            The UTC time of when the timeout expired.
            </summary>
        </member>
        <member name="P:Rebus.Messages.TimeoutReply.CorrelationId">
            <summary>
            The correlation ID as specified in the <see cref="T:Rebus.Messages.TimeoutRequest"/>.
            </summary>
        </member>
        <member name="P:Rebus.Messages.TimeoutReply.SagaId">
            <summary>
            The saga ID as specified in the <see cref="T:Rebus.Messages.TimeoutRequest"/>.
            </summary>
        </member>
        <member name="P:Rebus.Messages.TimeoutReply.CustomData">
            <summary>
            The custom data as specified in the <see cref="T:Rebus.Messages.TimeoutRequest"/>.
            </summary>
        </member>
        <member name="T:Rebus.OptimisticLockingException">
            <summary>
            Exception that gets thrown in cases where a race condition is detected for a piece of saga data.
            </summary>
        </member>
        <member name="T:Rebus.Timeout.IStoreTimeouts">
            <summary>
            Abstracts how timeouts are stored and retrieved when they are due.
            </summary>
        </member>
        <member name="M:Rebus.Timeout.IStoreTimeouts.Add(Rebus.Timeout.Timeout)">
            <summary>
            Should add the specified timeout to the store. An ambient transaction will
            be present, so the implementor should enlist if possible.
            </summary>
        </member>
        <member name="M:Rebus.Timeout.IStoreTimeouts.RemoveDueTimeouts">
            <summary>
            Should get all due timeouts and remove them at the same time. An ambient transaction
            will be present, so the implementor should enlist if possible.
            </summary>
        </member>
        <member name="T:Rebus.Persistence.Xml.XmlSubscriptionStorage">
            <summary>
            Class for storing Rebus subscriptions in XML
            </summary>
        </member>
        <member name="T:Rebus.IStoreSubscriptions">
            <summary>
            Implement this in order to affect how subscriptions are stored.
            </summary>
        </member>
        <member name="M:Rebus.IStoreSubscriptions.Store(System.Type,System.String)">
            <summary>
            Saves the association between the given message type and the specified endpoint name.
            </summary>
        </member>
        <member name="M:Rebus.IStoreSubscriptions.Remove(System.Type,System.String)">
            <summary>
            Removes the association between the given message type and the specified endpoint name.
            </summary>
        </member>
        <member name="M:Rebus.IStoreSubscriptions.GetSubscribers(System.Type)">
            <summary>
            Returns the endpoint names for the given message type.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.Xml.XmlSubscriptionStorage.#ctor(System.String)">
            <summary>
            Creates a new instance of the XmlSubscriptionStorage
            </summary>
            <param name="xmlFilePath">Full path to target XML document. File can exist with existing subscriptions, but will be created if not found. Process must have write access to target directory.</param>
        </member>
        <member name="M:Rebus.Persistence.Xml.XmlSubscriptionStorage.CreateSubscription(System.String,System.String)">
            <summary>
            Creates an XElement from a subscription set
            </summary>
            <param name="subscriberInputQueue">Queue name to store</param>
            <param name="type">Type to use</param>
            <returns>An XElement representing the subscription</returns>
        </member>
        <member name="M:Rebus.Persistence.Xml.XmlSubscriptionStorage.GetSubscriptionDocument">
            <summary>
            Loads the subscription document from disk if it exists, otherwise creates a new
            </summary>
            <returns>An XDocument with current subscriptions</returns>
        </member>
        <member name="M:Rebus.Persistence.Xml.XmlSubscriptionStorage.CreateSubscriptionDocument">
            <summary>
            Creates a new (and empty) subscription document
            </summary>
            <returns>An XDocument with no subscriptions</returns>
        </member>
        <member name="M:Rebus.Persistence.Xml.XmlSubscriptionStorage.GetSubscriptions(System.Xml.Linq.XDocument,System.String)">
            <summary>
            Gets a list of subscriptions
            </summary>
            <param name="doc">XDocument to search for subscriptions in</param>
            <param name="type">Optional type to search for</param>
            <returns>A list of current subscriptions</returns>
        </member>
        <member name="M:Rebus.Persistence.Xml.XmlSubscriptionStorage.Key(System.Type)">
            <summary>
            Gets the key for a message type
            </summary>
            <param name="t">Type to get key for</param>
            <returns>A key</returns>
        </member>
        <member name="M:Rebus.Persistence.Xml.XmlSubscriptionStorage.ClearAllSubscriptions">
            <summary>
            Clears all subscriptions
            </summary>
        </member>
        <member name="T:Rebus.Persistence.Xml.XmlSubscriptionStorage.Subscription">
            <summary>
            Helper class for subscription entries
            </summary>
        </member>
        <member name="P:Rebus.Persistence.Xml.XmlSubscriptionStorage.Subscription.Type">
            <summary>
            Gets or sets the type
            </summary>
        </member>
        <member name="P:Rebus.Persistence.Xml.XmlSubscriptionStorage.Subscription.Queue">
            <summary>
            Gets or sets the queue name
            </summary>
        </member>
        <member name="T:Rebus.ISerializeMessages">
            <summary>
            Implement this to specify how messages are represented as strings.
            </summary>
        </member>
        <member name="M:Rebus.ISerializeMessages.Serialize(Rebus.Messages.Message)">
            <summary>
            Serializes the specified <see cref="T:Rebus.Messages.Message"/> object into a <see cref="T:Rebus.TransportMessageToSend"/>,
            which is just a container for a headers dictionary and a byte array for the body.
            </summary>
        </member>
        <member name="M:Rebus.ISerializeMessages.Deserialize(Rebus.ReceivedTransportMessage)">
            <summary>
            Deserializes the specified <see cref="T:Rebus.ReceivedTransportMessage"/>, which is a container for a
            headers dictionary, a byte array for the body, and an ID (possibly assigned by the infrastructure),
            into a <see cref="T:Rebus.Messages.Message"/> object.
            </summary>
        </member>
        <member name="T:Rebus.SimpleHandlerActivator">
            <summary>
            Very simple implementation of the handler activator that allows a bunch of types to be manually registered,
            either with their type or with a factory method.
            </summary>
        </member>
        <member name="M:Rebus.SimpleHandlerActivator.Register(System.Type)">
            <summary>
            Registers the given handler type. It is assumed that the type registered has a public
            default constructor - otherwise, instantiation will fail.
            </summary>
        </member>
        <member name="M:Rebus.SimpleHandlerActivator.Register``1(System.Func{``0})">
            <summary>
            Registers a factory method that is capable of creating a handler instance.
            </summary>
        </member>
        <member name="M:Rebus.SimpleHandlerActivator.Handle``1(System.Action{``0})">
            <summary>
            Registers a function that can handle messages of the specified type.
            </summary>
        </member>
        <member name="T:Rebus.RebusTimeMachine">
            <summary>
            Static gateway to the current time. Implements the classic fake time pattern
            found in all the right places. The name is goofy on purpose to avoid colliding with people's own
            Time classes.
            </summary>
        </member>
        <member name="M:Rebus.RebusTimeMachine.Now">
            <summary>
            Gets the current time in UTC.
            </summary>
        </member>
        <member name="M:Rebus.RebusTimeMachine.Today">
            <summary>
            Gets the date of today in UTC.
            </summary>
        </member>
        <member name="T:Rebus.TimeMachine">
            <summary>
            Static gateway to ways of faking the current time. Should only be used in testing scenarios.
            </summary>
        </member>
        <member name="M:Rebus.TimeMachine.FixTo(System.DateTime)">
            <summary>
            Fixes the current time to the specified time which
            should be provided in UTC.
            </summary>
        </member>
        <member name="M:Rebus.TimeMachine.Reset">
            <summary>
            Resets fake time and returns to yielding the actual time.
            </summary>
        </member>
        <member name="T:Rebus.TransportMessageToSend">
            <summary>
            Message container that contains the parts of a single transport message that should be sent.
            It carries a headers dictionary and a body byte array. The <seealso cref="P:Rebus.TransportMessageToSend.Label"/> can be used
            to label the message somehow, which can then be used to show the message if the infrastructure
            supports it.
            </summary>
        </member>
        <member name="P:Rebus.TransportMessageToSend.Headers">
            <summary>
            Message headers. Pre-defined header keys can be found in <see cref="T:Rebus.Shared.Headers"/>.
            </summary>
        </member>
        <member name="P:Rebus.TransportMessageToSend.Body">
            <summary>
            Message body. Should not contain any header information.
            </summary>
        </member>
        <member name="P:Rebus.TransportMessageToSend.Label">
            <summary>
            String label to use if the underlying message queue supports it.
            </summary>
        </member>
        <member name="T:Rebus.Transports.Encrypted.RijndaelHelper">
            <summary>
            Encryption helper that encapsulated the Rijndael-specified stuff. Basically just
            gives <see cref="T:System.Security.Cryptography.RijndaelManaged"/> a decent API.
            </summary>
        </member>
        <member name="M:Rebus.Transports.Msmq.MsmqConfigurationExtension.UseMsmq(Rebus.Configuration.RebusTransportConfigurer,System.String,System.String)">
            <summary>
            Specifies that you want to use MSMQ to both send and receive messages. The input
            queue will be automatically created if it doesn't exist.
            </summary>
        </member>
        <member name="M:Rebus.Transports.Msmq.MsmqConfigurationExtension.UseMsmqAndGetInputQueueNameFromAppConfig(Rebus.Configuration.RebusTransportConfigurer)">
            <summary>
            Specifies that you want to use MSMQ to both send and receive messages. The input
            queue name will be deduced from the Rebus configuration section in the application
            configuration file. The input queue will be automatically created if it doesn't exist.
            </summary>
        </member>
        <member name="T:Rebus.TrivialPipelineInspector">
            <summary>
            The trivial pipeline inspector is an implementation of <see cref="T:Rebus.IInspectHandlerPipeline"/>
            that doesn't actually do anything. It can be used when you don't care about the handler
            pipeline, and then you can switch it for something else some time in the future when you
            feel like it.
            </summary>
        </member>
        <member name="M:Rebus.TrivialPipelineInspector.Filter(System.Object,System.Collections.Generic.IEnumerable{Rebus.IHandleMessages})">
            <summary>
            Returns the unmodified sequence of handlers.
            </summary>
        </member>
        <member name="T:Rebus.IAmInitiatedBy`1">
            <summary>
            Special handler implementation that is allowed to initiate a new saga instance when
            the incoming message cannot be correlated with an existing saga.
            </summary>
            <typeparam name="TMessage">The type of the message being handled. Can be any assignable type as well.</typeparam>
        </member>
        <member name="T:Rebus.ISagaData">
            <summary>
            The minimal interface that must be implemented by a class in order to model the state of a saga.
            The state is of course pretty trivial if you don't extend it with some fields and objects.
            </summary>
        </member>
        <member name="P:Rebus.ISagaData.Id">
            <summary>
            This is the ID of the saga. It should be set in the saga data, e.g. in the constructor
            of the class implementing this interface, ensuring that has been set when the saga
            is persisted the first time.
            </summary>
        </member>
        <member name="P:Rebus.ISagaData.Revision">
            <summary>
            This is the revision of this saga. It may be used by the saga persister to implement
            optimistic locking. Not all saga persisters need to do this though. Please don't mess
            with this one in your code.
            </summary>
        </member>
        <member name="T:Rebus.IStartableBus">
            <summary>
            Represents a bus that wants to be started before it can be used.
            </summary>
        </member>
        <member name="M:Rebus.IStartableBus.Start">
            <summary>
            Starts the bus.
            </summary>
        </member>
        <member name="T:Rebus.IStoreSagaData">
            <summary>
            Implement this in order to control how saga data gets persisted.
            </summary>
        </member>
        <member name="M:Rebus.IStoreSagaData.Insert(Rebus.ISagaData,System.String[])">
            <summary>
            Inserts the specified saga data, ensuring that the specified fields can be used
            to correlate with incoming messages. If a saga already exists with the specified
            ID and/or correlations, an <see cref="T:Rebus.OptimisticLockingException"/> must be thrown.
            </summary>
        </member>
        <member name="M:Rebus.IStoreSagaData.Update(Rebus.ISagaData,System.String[])">
            <summary>
            Updates the specified saga data in the underlying data store, ensuring that the
            specified fields can be used to correlate with incoming messages. If the saga no
            longer exists, or if the revision does not correspond to the expected revision number,
            and <see cref="T:Rebus.OptimisticLockingException"/> must be thrown.
            </summary>
        </member>
        <member name="M:Rebus.IStoreSagaData.Delete(Rebus.ISagaData)">
            <summary>
            Deletes the specified saga data from the underlying data store.
            </summary>
            <param name="sagaData"></param>
        </member>
        <member name="M:Rebus.IStoreSagaData.Find``1(System.String,System.Object)">
            <summary>
            Queries the underlying data store for the saga whose correlation field has a value
            that mathces the given field from the incoming message.
            </summary>
        </member>
        <member name="T:Rebus.MessageContext">
            <summary>
            Holds information about the message currently being handled on this particular thread.
            </summary>
        </member>
        <member name="T:Rebus.Shared.Headers">
            <summary>
            Contains keys of headers with special meaning in Rebus.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.Encrypted">
            <summary>
            Specifies that the contents of the message has been encrypted.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.EncryptionSalt">
            <summary>
            Key of header that contains the salt that was used when encrypting this message
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.MessageId">
            <summary>
            Key of header that contains the unique ID of the message.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.ReturnAddress">
            <summary>
            Key of header that specifies the return address of a message.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.OriginalReturnAddress">
            <summary>
            Key of header that specifies the original return address of a message. This can be used
            to specify the original sender's address in cases where a message is forwarded on another
            service's behalf.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.ErrorMessage">
            <summary>
            Key of header that contains an error message that stems from someone having experienced bad things trying to handle this message.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.TimeToBeReceived">
            <summary>
            Key of header that specifies the maximum time a sent/published message is valid. This can/should be used by the infrastructure
            to allow messages to expire when they are no longer relevant.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.SourceQueue">
            <summary>
            Key of source queue name - is attached to poison messages when they are moved to the error queue, allowing
            someone to re-deliver the message when the receiver is ready to retry.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.ContentType">
            <summary>
            Specifies the type of the content included in the body of the message.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.Encoding">
            <summary>
            In the event that the content is some kind of string, this header indicates which encoding was used
            when serializing the string.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.Express">
            <summary>
            Indicates that this message may be delivered faster if it is possible, most likely at the expense of
            delivery guarantee. E.g. a message queue might not durably persist the message when this header is
            added, which might lead to message loss in the event of a server crash.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.Multicast">
            <summary>
            Indicates thats the message will be sent using some kind of multicast protocol. This might lead transport
            implementations to behave differently.
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.SqlServerSagaPersister">
            <summary>
            Implements a saga persister for Rebus that stores sagas as a JSON serialized object in one table
            and correlation properties in an index table on the side.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaPersister.#ctor(System.String,System.String,System.String)">
            <summary>
            Constructs the persister with the ability to create connections to SQL Server using the specified connection string.
            This also means that the persister will manage the connection by itself, closing it when it has stopped using it.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaPersister.#ctor(System.Func{System.Data.SqlClient.SqlConnection},System.String,System.String)">
            <summary>
            Constructs the persister with the ability to use an externally provided <see cref="T:System.Data.SqlClient.SqlConnection"/>, thus allowing it
            to easily enlist in any ongoing SQL transaction magic that might be going on. This means that the perister will assume
            that someone else manages the connection's lifetime.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaPersister.EnsureTablesAreCreated">
            <summary>
            Creates the necessary saga storage tables if they haven't already been created. If a table already exists
            with a name that matches one of the desired table names, no action is performed (i.e. it is assumed that
            the tables already exist).
            </summary>
        </member>
        <member name="P:Rebus.Persistence.SqlServer.SqlServerSagaPersister.SagaIndexTableName">
            <summary>
            Returnes the name of the table used to store correlation properties of saga instances
            </summary>
        </member>
        <member name="P:Rebus.Persistence.SqlServer.SqlServerSagaPersister.SagaTableName">
            <summary>
            Returns the name of the table used to store JSON serializations of saga instances.
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage">
            <summary>
            Implements a subscriotion storage for Rebus that will store subscriptions in an SQL Server.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage.#ctor(System.String,System.String)">
            <summary>
            Constructs the storage with the ability to create connections to SQL Server using the specified connection string.
            This also means that the storage will manage the connection by itself, closing it when it has stopped using it.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage.#ctor(System.Func{System.Data.SqlClient.SqlConnection},System.String)">
            <summary>
            Constructs the storage with the ability to use an externally provided <see cref="T:System.Data.SqlClient.SqlConnection"/>, thus allowing it
            to easily enlist in any ongoing SQL transaction magic that might be going on. This means that the storage will assume
            that someone else manages the connection's lifetime.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage.EnsureTableIsCreated">
            <summary>
            Creates the necessary subscripion storage table if it hasn't already been created. If a table already exists
            with a name that matches the desired table name, no action is performed (i.e. it is assumed that
            the table already exists).
            </summary>
        </member>
        <member name="P:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage.SubscriptionsTableName">
            <summary>
            Returns the name of the table used to store subscriptions
            </summary>
        </member>
        <member name="T:Rebus.ReceivedTransportMessage">
            <summary>
            Message container that contains the received parts of a single transport message.
            It carries a headers dictionary, a body byte array, and an ID which is
            most like assigned by the infrastructure. The ID is used to track retries in the event that
            delivery fails.
            </summary>
        </member>
        <member name="M:Rebus.ReceivedTransportMessage.ToForwardableMessage">
            <summary>
            Converts this message into a forwardable <see cref="T:Rebus.TransportMessageToSend"/>.
            </summary>
        </member>
        <member name="P:Rebus.ReceivedTransportMessage.Id">
            <summary>
            Id given to this message, most likely by the queue infrastructure.
            It is important that the message can be uniquely identified - otherwise
            message retry will not be able to recognize the message between retries.
            </summary>
        </member>
        <member name="P:Rebus.ReceivedTransportMessage.Headers">
            <summary>
            Message headers. Pre-defined header keys can be found in <see cref="T:Rebus.Shared.Headers"/>.
            </summary>
        </member>
        <member name="P:Rebus.ReceivedTransportMessage.Body">
            <summary>
            Message body. Should not contain any header information.
            </summary>
        </member>
        <member name="P:Rebus.ReceivedTransportMessage.Label">
            <summary>
            String label used if the underlying message queue supports it.
            </summary>
        </member>
        <member name="T:Rebus.Transports.Msmq.RebusTransportMessageFormatter">
            <summary>
            MSMQ message formatter that should be capable of properly formatting MSMQ
            messages containins a raw byte stream.
            </summary>
        </member>
        <member name="T:Rebus.Transports.Msmq.MsmqMessageQueue">
            <summary>
            MSMQ implementation of <see cref="T:Rebus.ISendMessages"/> and <see cref="T:Rebus.IReceiveMessages"/>. Will
            enlist in ambient transaction during send and receive if one is present.
            </summary>
        </member>
        <member name="T:Rebus.Transports.Msmq.MsmqTransactionWrapper">
            <summary>
            Wraps a <see cref="P:Rebus.Transports.Msmq.MsmqTransactionWrapper.MessageQueueTransaction"/>, hooking it up to the ongoing
            ambient transaction if one is started, ignoring any calls to <see cref="M:Rebus.Transports.Msmq.MsmqTransactionWrapper.Commit"/>
            and <see cref="M:Rebus.Transports.Msmq.MsmqTransactionWrapper.Abort"/>. If no ambient transaction was there, calls to
            <see cref="M:Rebus.Transports.Msmq.MsmqTransactionWrapper.Commit"/> and <see cref="M:Rebus.Transports.Msmq.MsmqTransactionWrapper.Abort"/> will just be passed on to
            the wrapped transaction.
            </summary>
        </member>
        <member name="T:Rebus.Bus.RebusBus">
            <summary>
            Implements <see cref="T:Rebus.IBus"/> as Rebus would do it.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.#ctor(Rebus.IActivateHandlers,Rebus.ISendMessages,Rebus.IReceiveMessages,Rebus.IStoreSubscriptions,Rebus.IStoreSagaData,Rebus.IDetermineDestination,Rebus.ISerializeMessages,Rebus.IInspectHandlerPipeline,Rebus.Bus.IErrorTracker)">
            <summary>
            Constructs the bus with the specified ways of achieving its goals.
            </summary>
            <param name="activateHandlers">The bus will use this to construct handlers for received messages.</param>
            <param name="sendMessages">Will be used to send transport messages when you send, publish, and reply.</param>
            <param name="receiveMessages">Will be used to receive transport messages. If the bus is configured to run with multiple threads, this one should be reentrant.</param>
            <param name="storeSubscriptions">Will be used to store subscription information. Is only relevant if the bus is a publisher, i.e. it publishes messages and other services assume they can subscribe to its messages.</param>
            <param name="storeSagaData">Will be used to store saga data. Is only relevant if one or more handlers are derived from <see cref="T:Rebus.Saga"/>.</param>
            <param name="determineDestination">Will be used to resolve a destination in cases where the message destination is not explicitly specified as part of a send/subscribe operation.</param>
            <param name="serializeMessages">Will be used to serialize and deserialize transport messages.</param>
            <param name="inspectHandlerPipeline">Will be called to inspect the pipeline of handlers constructed to handle an incoming message.</param>
            <param name="errorTracker">Will be used to track failed delivery attempts.</param>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Start(System.Int32)">
            <summary>
            Starts the <see cref="T:Rebus.Bus.RebusBus"/> with the specified number of worker threads.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.SetNumberOfWorkers(System.Int32)">
            <summary>
            Sets the number of workers in this <see cref="T:Rebus.Bus.RebusBus"/> to the specified
            number. The number of workers must be greater than or equal to 0.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.InternalSend(System.String,System.Collections.Generic.List{System.Object})">
            <summary>
            Core send method. This should be the only place where calls to the bus'
            <see cref="T:Rebus.ISendMessages"/> instance gets called, except for when moving
            messages to the error queue. This method will bundle the specified batch
            of messages inside one single transport message, which it will send.
            </summary>
        </member>
        <member name="T:Rebus.Messages.SubscriptionMessage">
            <summary>
            Control bus message which is used to tell someone that 
            the sender wishes to subscribe to a particular message type.
            </summary>
        </member>
        <member name="T:Rebus.Messages.SubscribeAction">
            <summary>
            Describes what the subscription message is actually supposed to do.
            </summary>
        </member>
        <member name="T:Rebus.Messages.Message">
            <summary>
            Message wrapper object that may contain a collection of headers and multiple logical messages.
            </summary>
        </member>
        <member name="M:Rebus.Messages.Message.GetHeader(System.String)">
            <summary>
            Gets the string header with the specified key or null if the given key is not present
            or is not a string, Lookup names of pre-defined keys via <see cref="P:Rebus.Messages.Message.Headers"/>.
            </summary>
        </member>
        <member name="M:Rebus.Messages.Message.GetLabel">
            <summary>
            Gets some kind of headline that somehow describes this message. May be used by the queue
            infrastructure to somehow label a message.
            </summary>
        </member>
        <member name="P:Rebus.Messages.Message.Headers">
            <summary>
            Headers of this message. May include metadata like e.g. the address of the sender.
            </summary>
        </member>
        <member name="P:Rebus.Messages.Message.Messages">
            <summary>
            Collection of logical messages that are contained within this transport message.
            </summary>
        </member>
    </members>
</doc>
